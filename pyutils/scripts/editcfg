#!/usr/bin/env python
"""TODO
"""
import argparse
import logging.config
import os
import platform
from logging import NullHandler

import pyutils
from pyutils.genutils import (get_cfg_dict, get_logger_name,
                              get_logging_filepath, get_main_cfg_filepath,
                              get_model_configs_dirpath,
                              get_model_config_filepaths,
                              list_model_info, run_cmd, setup_log)

logger = logging.getLogger(get_logger_name(__name__, __file__, 'scripts'))
logger.addHandler(NullHandler())


def edit_config(cfg_filepath, app=None):
    """Edit a configuration file.

    The user chooses the config file (`cfg_filepath`) to edit: the
    `logging config file`_, `main config file`_ or a particular model
    configuration file (e.g. LogisticRegression)

    The configuration file can be opened by a user-specified application (`app`)
    or a default program associated with this type of file (when `app` is
    :obj:`None`).

    Parameters
    ----------
    cfg_filepath : str
        The configuration file to edit. The `logging config file`_,
        `main config file`_ or a particular model configuration file (e.g.
        LogisticRegression).
    app : str, optional
        Name of the application to use for opening the config file, e.g.
        `TextEdit` (the default value is :obj:`None` which implies that the
        default application will be used to open the config file).

    Returns
    -------
    retcode : int
        If there is a `subprocess
        <https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError>`_
        -related error, the return code is non-zero. Otherwise, it is 0 if the
        file can be successfully opened with an external program.

    """
    # Command to open the config file with the default application in the
    # OS or the user-specified app, e.g. `open filepath` in macOS opens the
    # file with the default app (e.g. atom)
    default_cmd_dict = {'Darwin': 'open {filepath}',
                        'Linux': 'xdg-open {filepath}',
                        'Windows': 'cmd /c start "" "{filepath}"'}
    # NOTE: check https://bit.ly/31htaOT (pymotw) for output from
    # platform.system on three OSes
    default_cmd = default_cmd_dict.get(platform.system())
    # NOTES:
    # - `app is None` implies that the default app will be used
    # - Otherwise, the user-specified app will be used
    cmd = default_cmd if app is None else app + " " + cfg_filepath
    retcode = 1
    result = None
    try:
        # IMPORTANT: if the user provided the name of an app, it will be used as
        # a command along with the file path, e.g. ``$ atom {filepath}``.
        # However, this case might not work if the user provided an app name
        # that doesn't refer to an executable, e.g. ``$ TextEdit {filepath}``
        # won't work. The failed case is further processed in the except block.
        result = run_cmd(cmd.format(filepath=cfg_filepath))
        retcode = result.returncode
    except FileNotFoundError:
        # This error happens if the name of the app can't be called as an
        # executable in the terminal
        # e.g. `TextEdit` can't be run in the terminal but `atom` can since the
        # latter refers to an executable.
        # To open `TextEdit` from the terminal, the command ``open -a TextEdit``
        # must be used on macOS.
        # TODO: IMPORTANT add the open commands for the other OSes
        specific_cmd_dict = {'Darwin': 'open -a {app}'.format(app=app)}
        # Get the command to open the file with the user-specified app
        cmd = specific_cmd_dict.get(platform.system(), app) + " " + cfg_filepath
        # TODO: explain DEVNULL, suppress stderr since we will display the error
        # TODO: IMPORTANT you might get a FileNotFoundError again?
        result = run_cmd(cmd)  # stderr=subprocess.DEVNULL)
        retcode = result.returncode
    if retcode == 0:
        logger.info("Opening the {} configuration file ...".format(
            os.path.basename(cfg_filepath)))
    else:
        if result:
            err = result.stderr.decode().strip()
            logger.error(err)
    return retcode


def setup_argparser():
    """Setup the argument parser for the command-line script.

    TODO

    Returns
    -------
    parser : argparse.ArgumentParser
        Argument parser.

    """
    # Setup the parser
    parser = argparse.ArgumentParser(
        # usage="%(prog)s [OPTIONS]",
        # prog=os.path.basename(__file__),
        description='''\
TODO\n''',
        # formatter_class=argparse.RawDescriptionHelpFormatter)
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    # TODO: package name too? instead of program name (e.g. train_models.py)
    parser.add_argument("--version", action='version',
                        version='%(prog)s v{}'.format(pyutils.__version__))
    parser.add_argument(
        "-lm", "--list-models", dest="list_models", action='store_true',
        help='''Show a list of all the supported ML models. Then the program
        exits.''')
    # Group arguments that are closely related
    # ===========
    # Edit config
    # ===========
    edit_group = parser.add_argument_group('Edit a configuration file')
    edit_group.add_argument(
        "-f", "--file", default='main',
        help='''Name of a configuration file to edit which can either be the
        main configuration file ('config'), logging configuration file ('log'),
        or a particular model configuration file (e.g. LogisticRegression). Use
        the -lm argument to get a complete list of all the supported ML models.
        ''')
    edit_group.add_argument(
        "-a", "--app-name", dest="app",
        help='''Name of the application to use for editing the file. If no name
        is given, then the default application for opening this type of file
        will be used.''')
    return parser


def main():
    parser = setup_argparser()
    args = parser.parse_args()

    # -------------------------------------
    # Get config filepath and setup logging
    # -------------------------------------)
    # Get config dict
    main_cfg_dict = get_cfg_dict('main')
    setup_log(main_cfg_dict['quiet'], main_cfg_dict['verbose'])

    # -------------------
    # -l : list ML models
    # -------------------
    if args.list_models:
        list_model_info()
        return 0

    # -------------------------------------
    # -e and -a : edit a configuration file
    # -------------------------------------
    if args.file in ['log', 'logging']:
        cfg_filepath = get_logging_filepath()
    elif args.file in ['main', 'config']:
        cfg_filepath = get_main_cfg_filepath()
    else:
        abbr_dict = list_model_info(print_msgs=False)
        args.file = args.file.lower()
        if abbr_dict.get(args.file):
            model_name = abbr_dict.get(args.file)
        else:
            model_name = args.file
        cfg_filepath = get_model_config_filepaths(
            root=get_model_configs_dirpath(), model_names=[model_name])
        if len(cfg_filepath) > 1:
            logger.warning("More than one model configuration files were retrieved")
            for fp in cfg_filepath:
                edit_config(fp, args.app)
            return 0
        elif cfg_filepath:
            cfg_filepath = cfg_filepath[0]
        else:
            raise ValueError(f"The model config file for '{args.file}' could "
                             "not be retrieved. Check the name of the "
                             "configuration file provided to the script.")
    edit_config(cfg_filepath, args.app)
    return 0


if __name__ == '__main__':
    main()
